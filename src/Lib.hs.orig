{-# LANGUAGE NamedFieldPuns, OverloadedStrings, RecordWildCards,BlockArguments,ScopedTypeVariables #-}

module Lib
    ( 
           MyWeatherProject(..)
         , ToDo(..)  
         , mymovingAVGTime
         , getMyCSV
         , modifyTVar_
         , doesNameExist
         , setFilePath
         , getTVar
         , parsecsv'
         , loopThroughData
         , writeToCSV
         , getDiagram
         , uploadData
         , getString
         , toString
         , parseArgs
         , getPair
         , setArguments
    ) where

import System.Environment (getArgs)    
import System.IO
import System.FilePath
import System.Exit
import System.Directory (doesDirectoryExist, doesFileExist,getCurrentDirectory, getDirectoryContents)
import qualified System.Console.GetOpt as SCG
import Control.Concurrent.STM
import qualified Data.Map as Map
import Data.Csv
import Data.String
import qualified Data.Vector as V
import qualified Data.Text as T
import Data.List
import Control.Monad
import Control.Monad.IO.Class
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy.UTF8 as BLU 
import qualified Graphics.Vega.VegaLite as VL
import qualified GitHubRelease as G
import Paths_weather_project (version)
import Data.Version (showVersion)

                         
-- data OptDescr a = Option [Char] [String] (ArgDescr a) String

{- data Flag = Help | CSV String String | Chart String String | T
            deriving Eq -}
            
data Flag = Verbose | Version | Help | Quit | CSV String | Chart String | Test | Region String deriving (Eq , Show)

data ToDo a = TestData | UserData a | UserChart a deriving (Eq,Show)
            
{- data ArgDescr a = NoArg a
                | ReqArg ((String,String) -> a) String
                | OptArg (Maybe String -> a) String -}
            
            
            
type CSVPath = FilePath
type HtmlPath = FilePath
type CSVLink = T.Text
type MyData = T.Text
type MyCSVPath = TVar CSVPath
type MyHtmlPath = TVar HtmlPath
type MyRegion = TVar MyData
type MyLink = TVar CSVLink
type Temperature = Float
type STemperature = T.Text
type DiagramTitle = T.Text

type MyGithub = T.Text
type DataHeader = BS.ByteString
type Year = Int
type MovingAVGInterval = Int
data MTemperature = TJust Temperature | TNothing deriving (Show,Eq)
data AVGTemperature = Global MTemperature | Milan MTemperature deriving (Show,Eq)
data WeatherData = WeatherData
    {     year   :: !Year
        , temperature :: !STemperature
    }
    
data WeatherComparison = WeatherComparison
    {     yearComparison   :: Year
        , temperatureMovAVG :: Temperature
        , dataCategory :: MyData
    }
    
{- data WeatherComparison = WeatherComparison
  {     yearComparison   :: Year
        , temperatureGlobal :: Temperature
        , temperatureMilan :: Temperature
   } -}

type DataCollection = Map.Map Year MTemperature
type MyDataCollection = TVar DataCollection
-- tupel entfernen und alle temperaturen untereinander speichern
type AvgDataCollection = Map.Map Year (AVGTemperature,AVGTemperature)
type MyMovingAVGCollection = TVar AvgDataCollection


data MyWeatherProject = MyWeatherProject
    {
          pathCSVGlobal :: MyCSVPath
        , pathCSVMilan  :: MyCSVPath
        , pathMyCSV  :: MyCSVPath
        , pathCSV :: CSVPath
        , pathMyChart :: MyHtmlPath
        , linkCSVFile :: MyLink
        , region1 :: MyRegion
        , region2 :: MyRegion
        , globalData :: MyDataCollection 
        , milanData :: MyDataCollection
        , avgData :: MyMovingAVGCollection
        , xAxisStep :: Year
        , githubOwner :: MyGithub
        , githubRepo :: MyGithub
        , githubToken :: MyGithub
        , movingAverageTime :: Year
    }

emptyMilan :: DataCollection
emptyMilan = Map.empty

emptyGlobal :: DataCollection
emptyGlobal = Map.empty    

empty :: AvgDataCollection
empty = Map.empty  

mychartfile :: HtmlPath
mychartfile = "moving-averages.html"
    
csvGlobal :: CSVPath
csvGlobal = "results-global.csv"

csvMilan :: CSVPath
csvMilan = "results-milan.csv"

myCsvFile :: CSVPath
myCsvFile = "moving-average-weather-data.csv"

mypath :: CSVPath
-- mypath = "/home/angie/Documents/UNI/Udacity/data-analysis-nanodegree/01-weather-project/01-project"
mypath = "data"

mymovingAVGTime :: Year
mymovingAVGTime = 10

mystep :: Year
mystep = 5

myCsvLink :: CSVLink
myCsvLink = "https://raw.githubusercontent.com/amxyz-cyber/temp/8042057626ab000a5fc83ea95ac7d770570853fc/moving-average-weather-data.csv"

yearHeader :: DataHeader
yearHeader = BL.toStrict $ BLU.fromString "year"

dataHeader :: DataHeader
dataHeader = BL.toStrict $ BLU.fromString "data"

maHeader :: DataHeader
maHeader = BL.toStrict $ BLU.fromString $ (show mymovingAVGTime) ++ "-" ++ BLU.toString (BL.fromStrict yearHeader) ++ "_MA"

globalHeader :: DataHeader
globalHeader = BL.toStrict $ BLU.fromString $ (show mymovingAVGTime) ++ "-" ++ BLU.toString (BL.fromStrict yearHeader) ++ "_global_MA"

milanHeader :: DataHeader
milanHeader = BL.toStrict $ BLU.fromString $ (show mymovingAVGTime) ++ "-" ++ BLU.toString ( BL.fromStrict yearHeader) ++ "_milan_MA"

xAxisTitle :: DiagramTitle
xAxisTitle = T.pack $ (show mymovingAVGTime) ++ "-" ++ BLU.toString (BL.fromStrict yearHeader) ++ " Moving Averages"

legend :: DiagramTitle
legend = "Data"

milanT :: MyData
milanT = "milan"

globalT :: MyData
globalT = "global"

regionA :: MyData
regionA = "region1"

regionB :: MyData
regionB = "region2"

gToken :: MyGithub
gToken = "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"

gOwner :: MyGithub
gOwner = "amxyz-cyber"

gRepo :: MyGithub
gRepo = "temp"


getMyCSV = do 
      tstore <- atomically $ newTVar csvGlobal
      tstore2 <- atomically $ newTVar csvMilan
      tstore6 <- atomically $ newTVar myCsvFile
      tstore7 <- atomically $ newTVar mychartfile
      tstore3 <- atomically $ newTVar emptyGlobal
      tstore4 <- atomically $ newTVar emptyMilan
      tstore5 <- atomically $ newTVar empty
      tstore8 <- atomically $ newTVar myCsvLink
      tstore9 <- atomically $ newTVar globalT
      tstore10 <- atomically $ newTVar milanT
      
      return MyWeatherProject {
                 pathCSVGlobal = tstore
               , pathCSVMilan = tstore2
               , pathCSV = mypath
               , pathMyCSV = tstore6
               , pathMyChart = tstore7
               , globalData =  tstore3
               , milanData = tstore4
               , avgData = tstore5
               , xAxisStep = mystep
               , githubOwner = gOwner
               , githubRepo = gRepo
               , githubToken = gToken
               , linkCSVFile = tstore8
			   , region1 = tstore9
			   , region2 = tstore10
			   , movingAverageTime = mymovingAVGTime
    }
    
-- modifyTVar_ :: TVar a -> a -> STM ()
-- modifyTVar_ tv f = readTVar tv >>= writeTVar tv f
modifyTVar_ tv newVal = do
    atomically $ writeTVar tv newVal

getTVar tv  = do
    store <- atomically $ readTVar tv
    return store

doesNameExist :: FilePath -> IO Bool
doesNameExist name = do
    fileExists <- doesFileExist name
    if fileExists
      then return True
      else doesDirectoryExist name
      
-- setFilePath dir f = "static" </> dir </> f
setFilePath dir f = dir </> f

--parseArgs :: IO ([String], Int)
parseArgs = do
    argv <- getArgs
    -- return argv
    case parse argv of
		([],n,[]  ) 						-> return TestData
		(opts, n, [])						-> f (nub opts) n
		(_,_,errs)                          -> die errs
	where
		parse argv = SCG.getOpt SCG.Permute options argv
		header     = "Usage: weatherComparator [-h] [-c csv-file1] [-c csv-file2] [-d link] [-t] [-r region1] [-r region2]  "
		info       = SCG.usageInfo header options
		dump       = hPutStrLn stderr
		die errs   = dump (concat errs ++ info) >> exitWith (ExitFailure 1)
		help       =  dump info                  >> exitWith ExitSuccess
		quit       = putStrLn "Goodbye" >> exitWith ExitSuccess
		printVersion = putStrLn (showVersion version) >> exitWith ExitSuccess
		f opts n
		  | Help `elem` opts  = help 
		  | Version `elem` opts = printVersion
		  | Quit `elem` opts  = quit
		  | Test `elem` opts = return TestData
		  | otherwise = checkAllOptions opts help

isRegion (Region _) = True
isRegion _         = False

isCSV (CSV _) = True
isCSV _         = False

isChart (Chart _) = True
isChart _         = False
		
checkOptions [] n = []
checkOptions l@(x:xs) n
	| length l == n  = l
	-- | length l == n  && checkItem l = l
	| otherwise = []

checkItem [] = True
checkItem (x:xs) 
	| ' ' `elem` (getItem x) = False
	| otherwise = checkItem xs
		
getItem (Region y) = y
getItem (CSV y) = y
getItem (Chart y) = y
	
checkAllOptions opts h= do
	let lenR = 2
	let	lenCSV = 2
	let	lenC = 1
	let regions = checkOptions (filter isRegion opts) lenR
	let	csv = checkOptions (filter isCSV opts)  lenCSV
	let	chart = checkOptions (filter isChart opts)  lenC
	case (length regions == lenR,length csv == lenCSV,length chart == lenC) of
		(True,True,_) -> return $ UserData (csv ++ regions)
		(True,_,True) -> return $ UserChart (chart ++ regions)
		(_,True,_) -> return $ UserData csv
		(_,_,True) -> return $ UserChart chart
		(_,_,_) -> h

                         
options :: [SCG.OptDescr Flag]
options =
    [ SCG.Option ['v']     ["verbose"] (SCG.NoArg Verbose)           "chatty output on stderr"
    , SCG.Option ['V','?'] ["version"] (SCG.NoArg Version)           "show version number"
    , SCG.Option ['q']     ["quit"]   (SCG.NoArg Quit)		         "end program"
    , SCG.Option ['c']     ["csv"]	   (SCG.ReqArg CSV "FILES")      "csv file for temperature comparison"
    , SCG.Option ['d']     ["chart"]   (SCG.ReqArg Chart "LINK")     "create a diagram"
    , SCG.Option ['t']     ["test"]    (SCG.NoArg Test)			     "create a diagram based on test set"
    , SCG.Option ['r']     ["region"]  (SCG.ReqArg Region "REGIONS") "the name of a region"
    , SCG.Option ['h']     ["help"]    (SCG.NoArg Help)              "Show this help message"
    
    ]

setRegions [] mydata = return ()
setRegions (x:xs) mydata = do
	let MyWeatherProject{region1=tvReg1,region2=tvReg2} = mydata
	let x' = convert' x
	let y = convert' $ head xs
	modifyTVar_ tvReg1 x'
	modifyTVar_ tvReg2 y
	return ()
	where
		convert':: Flag -> MyData
		convert' x = T.pack $ getItem x
	
setCSVs [] mydata = return ()	
setCSVs (x:xs) mydata = do
	let MyWeatherProject{pathCSVGlobal=tvC1,pathCSVMilan=tvC2 } = mydata
	modifyTVar_ tvC1 (getItem x)
	modifyTVar_ tvC2 (getItem $ head xs)
	return ()

setChart [] mydata = return ()
setChart (x:[]) mydata = do
	let MyWeatherProject{linkCSVFile=tvLink} = mydata
	modifyTVar_ tvLink (T.pack $ getItem x)
	return ()

setArguments l mydata = do
	let regions = filter isRegion l
	let chart = filter isChart l
	let csv = filter isCSV l
	setRegions regions mydata
	setCSVs csv mydata
	setChart chart mydata
	

nth _ [] = Nothing
nth 0 l = Just $ head l
nth n l = auxNth 0 l
    where auxNth acc (x:xs)
            | acc == n = Just x
            | acc < n && n < length l = auxNth (acc + 1) xs
            | otherwise = Nothing

--mysum :: (Num a) => [a] -> a
mysum xs = foldl(\acc (x,TJust y) -> acc+y) 0 xs

-- avg :: (Num a) => [a] -> Float
avg xs = (mysum xs ) / (genericLength xs)

toMTemperature :: WeatherData -> MTemperature
toMTemperature (WeatherData{temperature=t}) 
    | T.length t > 0 = TJust $ convert t
    | otherwise = TNothing
    
    where
        convert :: STemperature -> Temperature
        convert x = read (T.unpack x)
        
insertTemperature :: Year -> MTemperature -> DataCollection -> DataCollection
insertTemperature y mt map = case Map.lookup y map of
    Nothing -> Map.insert y mt map
    _ -> map
    
insertGlobalAvgTemperature :: Year -> MTemperature -> AvgDataCollection -> AvgDataCollection
insertGlobalAvgTemperature y mt map = case Map.lookup y map of
    Nothing -> Map.insert y (Global mt,Milan TNothing) map
    Just (Global mgt,Milan mmt) -> Map.insert y (Global mt,Milan mmt) map
    Just (Global mgt,_) -> Map.insert y (Global mt,Milan TNothing) map
    Just (_,Milan mmt) -> Map.insert y (Global mt,Milan mmt) map
    _ -> map
    
insertMilanAvgTemperature :: Year -> MTemperature -> AvgDataCollection -> AvgDataCollection
insertMilanAvgTemperature y mt map = case Map.lookup y map of
    Nothing -> Map.insert y (Global TNothing,Milan mt) map
    Just (Global mgt,Milan mmt) -> Map.insert y (Global mgt,Milan mt) map
    Just (Global mgt,_) -> Map.insert y (Global mgt,Milan mt) map
    Just (_,Milan mmt) -> Map.insert y (Global TNothing,Milan mt) map
    _ -> map
 
setMax map1 map2
    | auxMax map1 < auxMax map2 = auxMax map1
    | otherwise = auxMax map2
    where 
        auxMax map = getPair $ Map.findMax map

setMin map1 map2
    | auxMin map1 > auxMin map2 = auxMin map1
    | otherwise = auxMin map2
    where 
        auxMin map = getPair $ Map.findMin map

getPair (g,_) = g         
        
getNextMax max' = max' + mymovingAVGTime - 1    
getNextMin min' = succ(min')
getNextMax2 max' = succ(max')

loopThroughData tstore tstore2 tstore3 = do
    storeG <- getTVar tstore
    storeM <- getTVar tstore2
    
    let min = setMin storeG storeM
        max = setMax storeG storeM
        iMax = getNextMax min
        isGlobal = True
        isMilan = False
    loop min iMax max isGlobal storeG tstore3 
    loop min iMax max isMilan storeM tstore3 
    return ()
    
    where
        loop iMin iMax max flag map tstore = do
            map2 <- getTVar tstore
            let isOK = checkInterval iMax max
            (mtemp,iMax') <- getMovingAVG map iMin iMax max
            case (isOK,mtemp,flag) of
                (False,_,_) -> return ()
                (_,TNothing,_) -> return ()
                (_,TJust _,True) -> do
                    let map2' = insertGlobalAvgTemperature iMax' mtemp map2
                        newMin = getNextMin iMin
                        newMax = getNextMax2 iMax'
                    atomically $ writeTVar tstore map2'
                    loop newMin newMax max flag map tstore
                (_,TJust _,_) -> do
                    let map2' = insertMilanAvgTemperature iMax' mtemp map2
                        newMin = getNextMin iMin
                        newMax = getNextMax2 iMax'
                    atomically $ writeTVar tstore map2'
                    loop newMin newMax max flag map tstore
                                            
        checkInterval iMax max
            | iMax <= max = True
            | otherwise = False

getMovingAVG map iMin iMax max = do
    (mmap,iMax') <- loop map iMin iMax max
    case mmap of
            (Just newMap) -> do
                let list = Map.toList newMap
                    currentAVG = avg list
                return $ (TJust currentAVG,iMax')
            _ -> return $ (TNothing,iMax')
        
    where
        loop map min max maxKey = do
            let newMap = getFilteredList map min max 
                len = Map.size newMap
                hasEnoughItems = isLongEnough len
                mmap = getNewMap hasEnoughItems newMap
            case(max >= maxKey, mmap) of
                (True,_) -> return (mmap,max)
                (_, Just _) -> return (mmap,max)
                (_,_) -> do
                    let newMax = succ(max)
                    loop map min newMax maxKey
        
        getFilteredList map min max =  Map.filterWithKey (\k v -> k >= min && k <= max && v /= TNothing ) map
        
        isLongEnough len 
            | len == mymovingAVGTime = True
            | otherwise = False
        
        getNewMap hasEnoughItems newMap
            | hasEnoughItems = Just newMap
            | otherwise = Nothing
            

{- createDataList :: AvgDataCollection -> [WeatherComparison]
createDataList map1 = map (\(key,(Global (TJust g),Milan (TJust m))) -> WeatherComparison{yearComparison=key,temperatureGlobal=g,temperatureMilan=m} ) (getList map1)
    where
        getList :: AvgDataCollection -> [(Year,(AVGTemperature,AVGTemperature))]
        getList map = Map.toAscList map -}
        
createMilanDataList :: AvgDataCollection -> MyData -> [WeatherComparison]
createMilanDataList map1 reg = map (\(key,(Global (TJust g),Milan (TJust m))) -> WeatherComparison{yearComparison=key,temperatureMovAVG=m,dataCategory=reg} ) (getList map1)
    where
        getList :: AvgDataCollection -> [(Year,(AVGTemperature,AVGTemperature))]
        getList map = Map.toAscList map
        
createGlobalDataList :: AvgDataCollection -> MyData -> [WeatherComparison]
createGlobalDataList map1 reg = map (\(key,(Global (TJust g),Milan (TJust m))) -> WeatherComparison{yearComparison=key,temperatureMovAVG=g,dataCategory=reg} ) (getList map1)
    where
        getList :: AvgDataCollection -> [(Year,(AVGTemperature,AVGTemperature))]
        getList map = Map.toAscList map

mydouble :: Int -> Double
mydouble x = a
  where a = fromIntegral x :: Double


itemHeader :: Header
itemHeader = V.fromList [ yearHeader, maHeader , dataHeader ]

instance FromNamedRecord WeatherData where
    parseNamedRecord r = WeatherData <$> r .: "year" <*> r .: "avg_temp"
    
parsecsv' c tstore = do
  case decodeByName c of
            Left err -> putStrLn err
            Right (_, v) -> V.forM_ v $ \ w -> do
            --putStrLn $ show (year w ) ++ " temp: " ++ T.unpack (temperature w) ++ " Farenheit"
                store <- getTVar tstore     
                let mt = toMTemperature w
                    map1 = insertTemperature (year w ) mt store
                atomically $ writeTVar tstore map1

-- spaltennamen der neuen csv-datei: year, avg_temperature,data: global, milan
instance ToNamedRecord WeatherComparison where
  toNamedRecord WeatherComparison{..} =
    namedRecord
      [ yearHeader .= yearComparison
      , maHeader .= temperatureMovAVG
      , dataHeader .= dataCategory
      ]
      
{- instance ToNamedRecord WeatherComparison where
  toNamedRecord WeatherComparison{..} =
    namedRecord
      [ yearHeader .= yearComparison
      , globalHeader .= temperatureGlobal
      , milanHeader .= temperatureMilan
      ] -}

writeToCSV :: FilePath -> MyMovingAVGCollection -> MyRegion -> MyRegion -> IO () 
writeToCSV fileName tstore tstore2 tstore3= do
    store <- getTVar tstore
    reg1 <- getTVar tstore2
    reg2 <- getTVar tstore3
    let dataList = (createGlobalDataList store reg1) ++ (createMilanDataList store reg2)
        bs = encodeByName itemHeader dataList
    BL.writeFile fileName bs
    

uploadData t owner repo tag fp f = G.upload t owner repo tag fp f
    -- putStrLn res

getString t = T.unpack t

toString :: CSVPath -> String
toString s = s

gaiaData :: T.Text -> VL.Data
gaiaData mycsv =
  let addFormat n = (n, VL.FoNumber)
      cols = [T.pack(BLU.toString (BL.fromStrict(globalHeader))),T.pack(BLU.toString (BL.fromStrict(milanHeader))) ]
      opts = [ VL.Parse (map addFormat cols), VL.CSV ]
  in VL.dataFromUrl mycsv opts

getDiagram htmlFile' min max step link title = do
    let htmlFile = T.pack htmlFile'
    VL.toHtmlFile htmlFile' $ createDiagram min max step link title
    return ()

createDiagram min' max' step' link title = 
    let max = mydouble max'
        min = mydouble min'
        step = mydouble step'
        xVal = T.pack(BLU.toString (BL.fromStrict(yearHeader )))
        yVal = T.pack(BLU.toString (BL.fromStrict(maHeader )))
        cols = T.pack(BLU.toString (BL.fromStrict(dataHeader )))
        xValUpper = T.toUpper xVal
        yValUpper = T.toUpper yVal
        colsUpper = T.toUpper cols

        axis = VL.PAxis [ VL.AxValues (VL.Numbers [ min,min+step.. max ]) ]
        bkg = VL.background "rgba(0, 0, 0, 0.05)"
        enc = VL.encoding 
                . VL.position VL.X [ VL.PName xVal, VL.PmType VL.Temporal ,axis, VL.PAxis [ VL.AxTitle xValUpper ] ] 
                . VL.position VL.Y [  VL.PName yVal, VL.PmType VL.Quantitative, VL.PScale [ VL.SZero False ], VL.PAxis [ VL.AxTitle "Temperature in Celcius" ]]
                . VL.color [ VL.MName cols, VL.MmType VL.Nominal,VL.MLegend [ VL.LTitle colsUpper], VL.MScale [ VL.SScheme "viridis" []] ]
        
    in VL.toVegaLite 
       [ 
       bkg
       , VL.mark VL.Line []
       , enc []
       , VL.dataFromUrl link [VL.CSV]
       , VL.width 1600
       , VL.height 800
       , VL.title title []
       ]
